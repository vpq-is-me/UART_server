#include "mSLIP.h"



// @brief
// @param pack
// @return
slip_err_t SLIP_prepare_packet(pc_transm_msg_t* pack) {
    uint16_t extra_length = 2;  //'END' as start and terminating symbol at transmittion
    uint16_t length;
    uint8_t* p;

    uint8_t crc=crc8(0x00,pack->raw_arr,pack->length);
    if ((pack->length + 1) > MAX_PC_MSG_LENGTH) return FAIL;  // not enough space in array for crc
    pack->raw_arr[pack->length]=crc;
    length = pack->length = pack->length + 1;
    p = pack->raw_arr;
    for (uint16_t i = 0; i < length; i++, p++) {
        if (*p == SLIP_END || *p == SLIP_ESC) {
            extra_length++;
        }
    }
    if ((length + extra_length) > MAX_PC_MSG_LENGTH) return FAIL;  // not enough space in array
    pack->length += extra_length;
    p = pack->raw_arr + length - 1;  // point to last significant byte from initial data payload
    *(p + extra_length) = SLIP_END;  // terminating 'END' symbol
    extra_length--;
    for (uint16_t i = length; i; i--) {
        switch (*p) {
            /* if it’s the same code as an END character, we send a
             * special two character code so as not to make the
             * receiver think we sent an END */
            case SLIP_END:
                *(p + extra_length) = SLIP_ESC_END;
                extra_length--;
                *(p + extra_length) = SLIP_ESC;
                break;
            /* if it’s the same code as an ESC character,
             * we send a special two character code so as not
             * to make the receiver think we sent an ESC */
            case SLIP_ESC:
                *(p + extra_length) = SLIP_ESC_ESC;
                extra_length--;
                *(p + extra_length) = SLIP_ESC;
                break;
            /* otherwise, we just send the character*/
            default:
                *(p + extra_length) = *p;
                break;
        }
        p--;
    }
    pack->raw_arr[0] = SLIP_END;  // now 'p' has to point to begining of array to transmit, i.e. 'type' member
    return OK;
}
/* RECV_PACKET: receives a packet into the buffer located at "p".
 * If more than len bytes are received, the packet will
 * be truncated.
 * Returns the number of bytes stored in the buffer.
 */
slip_err_t SLIP_parse_packet(pc_transm_msg_t* pack) {
    uint16_t length = pack->length;
    uint16_t extra_length = 0;
    uint8_t* p;

    /* sit in a loop reading bytes until we put together
     * a whole packet.
     * Make sure not to copy them into the packet if we
     * run out of room.
     */
    p = pack->raw_arr;
    uint8_t c;
    for (uint16_t i = 0; i < length; i++, p++) {
        c = *p;
        switch (c) {
            // if it’s an END character then if it is not first byte we at the end of packet
            case SLIP_END:
                /* a minor optimization: if there is no
                * data in the packet, ignore it. This is
                * meant to avoid bothering IP with all
                * the empty packets generated by the
                * duplicate END characters which are in
                Romkey [Page 5]
                RFC 1055 Serial Line IP June 1988
                * turn sent to try to detect line noise.
                */
                if (!i) {
                    extra_length++;
                    continue;
                } else if (i != length - 1) {  // somthing wrong! END must be occure only at the last data byte
                    return FAIL;
                } else {
                    pack->length -= extra_length + 1;
                    uint8_t crc=crc8(0x00,pack->raw_arr,pack->length);
                    pack->length-=1;
                    if(crc)return FAIL;
                    else return OK;
                }
                break;
            /* if it’s the same code as an ESC character, wait
             * and get another character and then figure out
             * what to store in the packet based on that.
             */
            case SLIP_ESC:
                extra_length++;
                c = *++p;
                i++;
                /* if "c" is not one of these two, then we
                 * have a protocol violation.
                 */
                switch (c) {
                    case SLIP_ESC_END:
                        *(p - extra_length) = SLIP_END;
                        break;
                    case SLIP_ESC_ESC:
                        *(p - extra_length) = SLIP_ESC;
                        break;
                    default:
                        return FAIL;
                        break;
                }
                break;
            /* here we fall into the default handler and let
             * it store the character for us
             */
            default:
                *(p - extra_length) = *p;
                break;
        }
    }
    return FAIL;  // we pass last byte and last byte is not END
}
